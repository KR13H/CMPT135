#include <iostream>
#include <cmath>
#include <string>
using namespace std;

string getUnsignedBinaryRepresentationString(int x, const int L)
{
	//Pre-condition: x >= 0 and L > 0
	//Post-condition: the unsigned binary representation of x in L bit pattern is returned as a C++ string data type
	//Assume that the pre-condition is satisfied

	string s;
	for(int i=0;i<L;i++){
		int a=x%2;
		x=x/2;
		if(a==1)
			s='1'+s;
		else 
			s='0'+s;
	}
	return s;

}
int getUnsignedBinaryDecimalValue(string s)
{
	//Pre-condition: s is non-empty and stores '0's and '1's characters
	//Post-condition: The decimal number value of the unsigned binary bits stored in s is returned
	//Assume that the pre-condition is satisfied
	int p=0;
	for(int j=0;j<s.length();j++)
	{
		if(s[j]=='1')
		{
			int a= pow(2,1.0*((s.length()-1)-j)); 
			p+=a; 
		}

	}
	return p;

}
string getSignAndMagnitudeBinaryRepresentationString(int x, const int L)
{
	//Pre-condition: x is any integer and L > 1
	//Post-condition: the sign and magnitude representation of x in L bit pattern is returned as a C++ string data type
	//Assume that the pre-condition is satisfied

	string s;
	int p=0;
	if(x>0){
		p=x;}
	else
		p=-(x);
	for(int i=0;i<L;i++)
	{
		int a=p%2;
		p=p/2;
		if(a==1)
			s='1'+s;
		else 
			s='0'+s;

	}

	if(x<0)
	{
		s[0]='1';
	}
	else
	{
		s[0]='0';
	}
	return s;

}


int getSignAndMagnitudeBinaryDecimalValue(string s)
{
	//Pre-condition: s.length() > 1 and stores '0's and '1's characters
	//Post-condition: The decimal number value of the sign and magnitude binary bits stored in s is returned
	//Assume that the pre-condition is satisfied

	int d=0;

	for(int j=1;j<s.length();j++)
	{
		if(s[j]=='1')
		{
			int a= pow(2,1.0*((s.length()-1)-j)); 
			d+=a; 
		}

	}

	if(s[0]=='1')
		d=-1*d;

	return d;
}
string getBinarySumString(string s1, string s2)
{
	//Pre-condition: s1 and s2 are non-empty, have equal lengths, and store '0's and '1's characters
	//Post-condition: The binary sum of the bits in s1 and s2 is returned as a C++ string data type with the same length as s1 and s2
	//Assume that the pre-condition is satisfied
	string s;
	int carry =0;
	for(int i =s1.length()-1;i>=0;i--)//We can use s1.length() for both cases s1 and s2 as both of the string have the same string size  
	{
		int sum = carry;
		if(i>=0)
		{
			sum+=s1[i]-'0';
			sum+=s2[i]-'0';
		}
		if(sum>1)
			carry = 1;
		else
			carry = 0;
		int r=sum%2; // because any remainder when divided by 2 is '1' or '0'
		if(r== 1)
			s= '1' + s;
		else
			s= '0' + s;
	}

	return s;
}
string getTwosComplementBinaryRepresentationString(int x, const int L)
{
	//Pre-condition: x is any integer and L > 0
	//Post-condition: the two's complement binary representation of x in L bit pattern is returned as a C++ string data type
	//Assume that the pre-condition is satisfied

	int p;	
	if(x<0)
		p=-x;
	else
		p=x;
	int x1=x;

	string s;
	if(x<0){	
		s=getUnsignedBinaryRepresentationString(p,L);
		for(int j=0;j<L;j++)
		{
			if(s[j]=='1')
				s[j] ='0';
			else 
				s[j]='1' ;
		}
		string s1="1";
		if(x1<0)
		{	
			for(int j=0;j<s.length()-1;j++){
				s1='0'+s1;
			}
			string d=getBinarySumString(s,s1);//using to add 1 and get the two's compliment 
			return d;
		}
	}
	else
		s=getUnsignedBinaryRepresentationString(x,L);
	return s;

}
int getTwosComplementBinaryDecimalValue(string s)
{
	//Pre-condition: s is non-empty and stores '0's and '1's characters
	//Post-condition: The decimal number value of the two's complement binary bits stored in s is returned
	//Assume that the pre-condition is satisfied
	int s1;
	if(s[0]=='1'){
		int d=getUnsignedBinaryDecimalValue(s);
		if(s[0]=='1')
			d=d*-1;
		string s1 = getTwosComplementBinaryRepresentationString(d,s.length());
		d=getUnsignedBinaryDecimalValue(s1);
		if(s[0]=='1')
			d=d*-1;
		return d;
	}
	else
		s1 = getUnsignedBinaryDecimalValue(s);

	return s1;
}
int selectComputation()
{
	cout << "Select your computation" << endl;
	cout << "   1. Unsigned Binary Representation Computation" << endl;
	cout << "   2. Sign and Magnitude Representation Computation" << endl;
	cout << "   3. Two's Complement Representation Computation" << endl;
	cout << "   4. Exit Program" << endl;
	int selection;
	cout << "Enter your selection (1, 2, 3, or 4): ";
	cin >> selection;
	while (selection != 1 && selection != 2 && selection != 3 && selection != 4)
	{
		cout << "Please enter a correct choice: ";
		cin >> selection;
	}
	return selection;
}
int main()
{
	cout << "This program demonstrates numeric information representation using" << endl;
	cout << " *** Unsigned Binary Representation" << endl;
	cout << " *** Sign and Magnitude Binary Representation" << endl;
	cout << " *** Two's Complement Binary Representation" << endl << endl;
	cout << "In addition, the program demonstrates" << endl;
	cout << " *** Two's complement binary addition, and" << endl;
	cout << " *** Conversion from two's complement to decimal." << endl << endl;
	do
	{
		int selection = selectComputation();
		if (selection == 1)
		{
			int bit_pattern_size, num;
			cout << endl << "Enter a positive integer for the bit pattern size: ";
			cin >> bit_pattern_size;
			while (bit_pattern_size <= 0)
			{
				cout << "You must enter a positive integer. Enter again please: ";
				cin >> bit_pattern_size;
			}
			cout << "Enter a non-negative integer: ";
			cin >> num;
			while (num < 0)
			{
				cout << "You must enter a non-negative integer. Enter again please: ";
				cin >> num;
			}
			string s = getUnsignedBinaryRepresentationString(num, bit_pattern_size);
			cout << "The unsigned binary representation of " << num << " in " << bit_pattern_size << " bit is " << s << endl;
			int value = getUnsignedBinaryDecimalValue(s);
			cout << "This unsigned binary represents the decimal number " << value << endl;
			if (value == num)
				cout << "This is a correct result." << endl;
			else
				cout << "This is not correct result because our bit pattern is too small to store the given decimal number." << endl;
			cout << endl;
		}
		else if (selection == 2)
		{
			int bit_pattern_size, num;
			cout << endl << "Enter a positive integer greater than 1 for the bit pattern size: ";
			cin >> bit_pattern_size;
			while (bit_pattern_size <= 1)
			{
				cout << "You must enter a positive integer greater than 1. Enter again please: ";
				cin >> bit_pattern_size;
			}
			cout << "Enter an integer: ";
			cin >> num;
			string s = getSignAndMagnitudeBinaryRepresentationString(num, bit_pattern_size);
			cout << "The sign and magnitude binary representation of " << num << " in " << bit_pattern_size << " bit is " << s << endl;
			int value = getSignAndMagnitudeBinaryDecimalValue(s);
			cout << "This sign and magnitude binary represents the decimal number " << value << endl;
			if (value == num)
				cout << "This is a correct result." << endl;
			else
				cout << "This is not correct result because our bit pattern is too small to store the given decimal number." << endl;
			cout << endl;
		}
		else if (selection == 3)
		{
			int bit_pattern_size, num1, num2;
			cout << endl << "Enter a positive integer for the bit pattern size: ";
			cin >> bit_pattern_size;
			while (bit_pattern_size <= 0)
			{
				cout << "You must enter a positive integer. Enter again please: ";
				cin >> bit_pattern_size;
			}
			cout << "Enter an integer: ";
			cin >> num1;
			string s1 = getTwosComplementBinaryRepresentationString(num1, bit_pattern_size);
			cout << "The two's complement binary representation of " << num1 << " in " << bit_pattern_size << " bit is " << s1 << endl;
			cout << endl;
			cout << "Enter a second integer: ";
			cin >> num2;
			string s2 = getTwosComplementBinaryRepresentationString(num2, bit_pattern_size);
			cout << "The two's complement binary representation of " << num2 << " in " << bit_pattern_size << " bit is " << s2 << endl;
			cout << endl;
			string s3 = getBinarySumString(s1, s2);
			cout << "The binary sum of " << s1 << " and " << s2 << " is " << s3 << endl;
			int sum = getTwosComplementBinaryDecimalValue(s3);
			cout << "The sum of " << num1 << " and " << num2 << " is " << num1+num2 << " and the integer value of the binary sum is " << sum << endl;
			if (sum == num1 + num2)
				cout << "This is a correct result." << endl;
			else
				cout << "This is not correct result because our bit pattern is too small to store the sum." << endl;
		}
		else
			break;
		system("Pause");
		cout << endl << endl;
	}while (true);

	system("Pause");
	return 0;
}
